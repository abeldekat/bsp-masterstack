#!/usr/bin/env bash

source "$ROOT/lib/state.sh";
source "$ROOT/lib/desktop.sh";
source "$ROOT/lib/bspc.sh";
source "$ROOT/handlers/config.sh";
source "$ROOT/handlers/runtime_globals.sh";
source "$ROOT/handlers/transform.sh";
source "$ROOT/handlers/orientation.sh";
source "$ROOT/handlers/master.sh";
source "$ROOT/handlers/dump.sh";
source "$ROOT/handlers/zoom.sh";
source "$ROOT/handlers/on_event.sh";

# @see _should_handle_event
_find_desktop_id_in_event(){
    local desktop_id="";
    if [[ "$1" == "node_transfer" ]]; then
        [[ "$3" != "$6" ]] && desktop_id="$6";
    else
        desktop_id="$3";
    fi;
    echo $desktop_id;
}

# Gatekeeper: Only handle event if:
# . The event is a user event generated by this project via a named pipe
# . Event target desktop is a match
# In case event is node_transfer: Event src desktop is not a match
_should_handle_event(){
    local cmd=$1;
    if [[ $cmd == "zoom" || $cmd == "rotate" || $cmd == "dump" ]]; then
        echo true;
        return;
    fi

    local result=false;
    local desktop_id="$(_find_desktop_id_in_event $@)";
    if [[ -n "$desktop_id" ]]; then
        local desktop_name_event=$(get_desktop_name_from_id "$desktop_id");
        [[ "$desktop_name_event" == "$DESKTOPNAME" ]] && result=true;
    fi;
    echo $result;
}

# Pass event to the correct method
_handle_event(){
    cmd=$1; shift;
    case "$cmd" in
      node_add) on_node_add "$@" ;;
      node_remove) on_node_remove "$@" ;;
      node_transfer) on_node_transfer "$@" ;;
      zoom) zoom ;;
      rotate) change_orientation ;;
      dump) dump ;;
      *) ;;
    esac;
}

# All events of interest
# 1. Bspwm events
# 2. Events generated by this project via a named pipe
_capture_events(){
    bspc subscribe node_add node_remove node_transfer &
    while :; do
        if read message <$THIS_DESKTOP_FIFO; then
            [[ "$message" == 'quit' ]] && break;
            echo $message;
        fi
    done &
}

# Acitvates listener for a specific desktop
# Reads both bspwm events and commands issued by this project through a fifo
# The fifo needs to be closed and removed on exit
_start() {
    {
        trap "echo quit > $THIS_DESKTOP_FIFO && rm $THIS_DESKTOP_FIFO" EXIT;
        while read -r -a line; do
            if "$(_should_handle_event ${line[@]})"; then
                _handle_event ${line[@]};
            fi;
        done < <(_capture_events)
    } &
    local ADAPTER_PID=$!;
    disown;
    set_desktop_option $DESKTOPNAME 'pid' "$ADAPTER_PID";
    set_desktop_option $DESKTOPNAME 'orientation' "$ORIENTATION";
    echo "[$ADAPTER_PID]";
}

# Masterstack global variables
DESKTOPNAME="$1"; shift; 
set_runtime_globals "$1"; shift;
# Create FIFO for this desktop in order to receive commands
THIS_DESKTOP_FIFO="$(get_desktop_fifo $DESKTOPNAME)";
if [[ ! -p $THIS_DESKTOP_FIFO ]]; then
    mkfifo $THIS_DESKTOP_FIFO;
fi
# Transform an existing layout if needed
transform_if_needed;
# Start the listener
_start;
